# Упражнение 01 - Вычислитель выражений

Напишем парсер дерева математических выражений и научимся делать с этим деревом операции
с использованием полезных паттернов проектирования (Visitor, Singleton).

## Условие

### 1. Базовый набор операторов.

Будем читать из стандартного ввода строку - математическое выражение, содержащее числа и операторы `+`, `-`.
После обработки в стандартный вывод нужно вывести:
1. Отладочное строковое представление получившегося дерева выражения (произвольный формат).
2. Высоту дерева выражения.
3. Результат вычисления выражения.
Если введённое выражение содержит ошибки (не является выражением), 
то необходимо напечатать сообщение об этом пользователю (произвольный формат). 

### 1.1. Расширенный набор операторов.

Разрешить использование в выражении операторов `*`, `/` и группирующих скобок `()`.

*ВАЖНО: Если готовы делать расширенную версию, то нужно сразу делать расширенную версию, так как парсинг выражения в базовой версии можно реализовать существенно проще.*

### 2. Вводим переменные.
*Можно вводить как в базовой, так и в расширенной версии.*

Разрешить использовать в выражении латинские символы - переменные.
При наличии во введённом выражении переменных необходимо запросить у пользователя значение для каждой переменной и вывести результат с учётом подстановки.

Пример работы приложения:
```
enter expression: (2 + x) * x - y
tree: sub(mul(paran-expr(add('2', var[x])), var[x]), var[y])
expr-tree depth: 5
value for 'x': 2
value for 'y': 1
result: 7
```

Так же см. **дополнительные пункты задания** после теоретической части.

## Нужное нам API и минутка теории.

В данном упражнении ожидается, что по введённому строковому выражению будет построено, так называемое, *дерево выражения*.

`(2 + x) * x - y` 

может быть представлено в виде дерева:

```
              sub
              / \
            mul  [y]
           /   \
          ()   [x]
         /
        add
       /  \
      2   [x]
```
В таком виде, чтобы, например, получить результат, нужно *обойти* (посетить) дерево *в глубину* последовательно вычисляя значение для каждого *под-выражения*, т. е.

Предлагается смоделировать такое дерево в Java и реализовать на нём нужные операции (вычисление результата, строковое представление).

Давайте смоделируем *выражение*:
```java
// file: Expression.java
public interface Expression {
  // Nothing here (yet?)
}

// file: Literal.java
public interface Literal extends Expression {
  double getValue();
}

// file: BinaryExpression.java
public interface BinaryExpression extends Expression {
  Expression getLeft();
  Expression getRight();
  BinOpKind getOperation();  // return type looks like enum, right?
}

// file: ParenthesisExpression.java
public interface ParenthesisExpression extends Expression {
  Expression getExpr();  // Whatever the expression is inside ().
}

// Возможно другие выражения
```

Первый этап обработки - парсинг выражения, а точнее построение дерева выражений по входной строке.
Можно смоделировать эту идею таким интерфейсом:
```java
public interface Parser {
  /**
   * [Такой комментарий к методу/классу/полю называется java-doc - распознается IDE как документация]
   *
   * Parses expression from the string.
   * If the string doesn't represent a valid expression, then 
   *  throws ExpressionParseException.
   *
   * @param input the input string.
   * @return parsed expression tree.
   */
  Expression parseExpression(String input) throws ExpressionParseException;
}
```

Мы определили, как мы будем получать дерево (с точки зрения интерфейса).
Но как нам работать с этим деревом? Тут существует несколько подходов.
Рассмотрим первый, который можно реализовать уже сейчас (не дополняя API):
```java
double computeExpression(Expression expression) {
  // runtime-проверка типов.
  if (expression instanceof BinaryExpression) {
    // Явное преобразование типов (выглядит как C-style cast в C++).
    BinaryExpression binary = (BinaryExpression) expression;
    return compute(binary.getLeft(), binary.getRight());
  } else if (expression instanceof Literal) {
    Literal literal = (Literal) expression;
    return literal.getValue();
  } else if (...) {
    ...
  } else {
    throw IllegalStateException(
       "I will most probably forget to support new expression types in this ugly if :(");
  }
}

String debugRepresentationForExpression(Expression expression) {
  // Такая же портянка if-else-if, уфф...
}
```
Так мы делать конечно же не будем -
это некрасивое, тяжело поддерживаемое решение, у которого будут проблемы с производительностью.

Вместо этого можно сделать подход через виртуальные функции:
```java
public interface Expression {
  /**
   * Recursively computes the result of this expression.
   */
  double compute();

  /**
   * Returns string representation of this expression for debugging purposes.
   */
  String debugRepresentation();
}

// Реализации для каждого класса будут более-менее очевидны.
```
Такой подход вполне приемлем, работоспособен и производителен.
Но есть идейный нюанс: мы можем хотеть от выражения совершенного разных вещей.
И если вычисление результата и имеет прямое отношение к выражению и потому оправдывает
свое расположение в интерфейсе `Expression` - "я выражение и меня можно вычислить",
то если мы захотим делать произвольные операции с деревом выражения, нам не круто будет
захламлять интерфейс Expression и каждый конкретный класс нашими "левыми" потребностями.
А если вынести `Expression` в общую библиотеку, а код писать в зависящем модуле, то у нас
совсем не будет возможности модифицировать интерфейс `Expression`. Как же быть в таком случае?

Подход (или, если хотите, паттерн) к решению такого типа проблем имеет в коммьюнити название "Visitor":
```java
// file: ExpressionVisitor.java
public interface ExpressionVisitor {
  Object visitBinaryExpression(BinaryExpression expr);
  Object visitLiteral(Literal expr);
  Object visitParenthesis(ParenthesisExpression expr);
}

// file: Expression.java
public interface Expression {
  Object accept(ExpressionVisitor visitor)
}
```
Каждая реализация интерфейса `Expression` будет звать у `visitor` метод, соответствующий своему типу, например, реализация `BinaryExpression` будет звать `visitBinaryExpression(this)`, и так далее.
Такой подход схож с первым вариантом через `instanceof`+cast, но более устойчив к ошибкам, и весь код обхода или "посещения" пишется один раз. 
Таким образом, при добавлении нового класса (интерфейса) в иерархию мы будем вынуждены реализовать там метод `accept`, где будем вынуждены вызвать новый метод визитора (который тут же и добавим) и далее будем вынуждены реализовать этот метод во всех своих реализациях визитора. Так мы будем в каждый момент времени уверены, что наша кодовая база поддерживает все существующие типы в конкретной "посещаемой" иерархии.

В рамках нашего примера у нас получится так:
```java
public class ComputeExpressionVisitor implements ExpressionVisitor {
  // ...
}
public class DebugRepresentationExpressionVisitor implements ExpressionVisitor {
  // ...
}
// ...
double result = (Double) expression.accept(new ComputeExpressionVisitor());
String debug = (String) expression.accept(new DebugRepresentationExpressionVisitor());
```

### Что нужно сделать?

Собственно, вам предстоит создать проект, верно перенести в него предложенные интерфейсы, реализовать их и правильно связать воедино в методе `main`. Для реализации нужных операций над деревом нужно использовать подход Visitor, как мы уже договорились выше.

Желательно быть устойчивыми к ошибкам пользовательского ввода. Например, в случае ошибки
предлагать пользователю перепроверить данные и ввести их ещё раз.

"Отладочное" представление дерева выражений можно выводить как вам нравится - можете хоть дерево нарисовать
из символов.

## Дополнительные пункты задания.

- Можно так же, в качестве упражнения, научиться выводить исходную строку выражения (с точностью до пробелов) по распаршенному объекту выражения `Expression`. 
Это можно сделать через преопределение метода `toString()` или как ещё один `Visitor`.
Можно даже сделать гибридное решение - `default toString()` в `Expression` будет делать `accept(new ToStringVisitor())`.

- Для тех классов "посетителей", которые не имеют состояния (stateless) - у который нет полей - не имеет смысла каждый раз создавать инстанс объекта - так мы только будем расходовать память (пустой объект в Java всё равно занимает память).
**Тут можно применить другой "паттерн" - "Singleton"**. В Java этот паттерн реализуется следующим образом:
```java
public ToStringVisitor implements ExpressionVisitor {
  private ToStringVisitor() {}  // приватный конструктор, чтобы никто не мог создать объект извне.

  // ...

  // Единственный инстанс этого класса.
  // Итого везде вместо `new ToStringVisitor()` пишем `ToStringVisitor.INSTANCE`.
  public static final INSTANCE = new ToStringVisitor();
}
```

## Напишите тесты

Попробуйте написать юнит-тесты к своей реализации парсинга.
Идеи для сценариев тестирования:
- возьмите строчку, сделайте для неё `parse` и проверьте, что toString() совпадает с исходной строкой с точностью до пробелов.
- проверьте результат вычисления выражения. Важно: выражение можно строить программно, чтобы проверить корректность только вычисления, а не парсинга. Парсинг стоит проверять отдельно. В этом основная суть юнит-тестирования - проверяется только один логический блок.

Если вы сделали проект на Gradle, то там есть поддержка юнит-тестов в самой билдсистеме и есть интеграция с IntelliJ. Если вы чувствуете в себе силы начать самостоятельно разбираться с Gradle и фреймворком для тестирования Junit 5 (Google it!) - советую уже сейчас пойти по этому пути, потому что в дальнейшем мы будем этим пользоваться.

Если вы сделали стандартный проект в IntelliJ Idea - пишите тесты руками прямо в отдельном тестовом `main`.


## Советы и примечания к реализации.

- Используйте стандартный проект IntelliJ Idea, укажите JDK версии >= 11. 
Использовать другие билд-системы, например, Gradle, пока не обязательно,
но если кто-то хочет попробовать разобраться - пожалуйста.

- Если у интерфейса одна логическая реализация, а сам *выделенный* интерфейс введён для удобства, то реализующий его класс принято назвать как интерфейс с постфиксом `Impl`: `class ParserImpl implements Parser`.

- Парсинг выражения с приоритетами операторов может быть не так просто реализовать;
если алгоритмы для этого вы не рассматривали ранее и не хотите разбирать алгоритмы из интернета,
то можно сделать только базовую версию с `+` и `-`, хотя за расширенную версию определенно вам будет плюсик. И если мы решим далее развивать тему этой лабы, то в какой-то момент все же может понадобиться написать расширенную версию. Если надо, то можем разобрать нужные алгоритмы на очных парах.

- В методе `accept` мы возвращаем тип `Object` - чтобы конкретные операции могли вернуть любой нужный им результат. Если результат не нужен, можно просто возвращать `null`. В месте вызова таким образом нужно явное преобразование. Очевидно, что мы бы хотели иметь более строго типизированное решение, чтобы избежать ошибок типов в рантайме. Для этого в Java есть механизм *обобщений* (*Generics*), которые мы ещё не проходили. Кто хочет - может попробовать начать разбираться самостоятельно и применить их тут :)

- Для поддержки переменных нужно ввести ещё один тип выражения. Запрос значений переменных у пользователя стоит сделать отдельным посетителем, который как результат вернёт `Map<String, Double>`. А вычисляющий посетитель уже будет принимать себе в конструктор этот `Map`, чтобы использовать значения переменных при вычислении.

- По всем вопросам к классам стандартной библиотеки смотрите их java-doc и пользуйтесь автокомплитом в IDE.
Так же очень полезно пользоваться stack-overflow и прочими ресурсами. Если не нашли сами ответ на любой вопрос - спрашивайте в телеграмм-чате курса, постараюсь вам помочь.

## Update #1

**Доп задания**:

_(Если сдали основное задание, то сделайте отдельный PR c реализацией дополнительных.
Если ещё не сдали - можно делать всё сразу)_

1. Так как прошли обобщения (generics), можно не возвращать тип `Object` из метода `accept` посетителя. Нужно сделать интерфейс
`ExpressionVisitor` обобщённым, и использовать тип-параметр как результат. Метод `accept` нужно, соответственно, так же
сделать обобщённым по возвращаемому значению и принимать визитор с нужным типом-параметром и нужной вариантностью*.
Это избавит нас от явных ручных преобразований типов.

---
&ast; смотри [variance.md](variance.md).